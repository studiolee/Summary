# 面试基本知识准备（主要以Java为主）

## 1.面向对象三要素

封装，继承，多态

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法，如果属性不想被外界访问，我们大可不必提供方法给外界访问。 

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承我们能够非常方便地复用以前的代码。 

## 2.什么是多态，怎么实现多态？

同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果，这就是多态性。简单的说:就是用**基类的引用指向子类的对象**。 

实现方法：子类继承父类重写方法；实现接口方法。

## 3.重载与重写的区别

方法重载是指同一个类中的多个方法具有相同的名字,但这些方法具有不同的参数列表,即参数的数量或参数类型不能完全相同

方法重写是存在子父类之间的,子类定义的方法与父类中的方法具有相同的方法名字,相同的参数表和相同的返回类型 

注:          (1)子类中不能重写父类中的final方法          (2)子类中必须重写父类中的abstract方法  

## 4.StringBuffer，StringBuilder，String

String是字符串常量（final 修饰的数组），不可修改，操作String对象时，需要生成新的字符串将原引用指向新的内存地址，消耗时间多，但是可以保证线程安全，因为String对象是常量。

StringBuffer对象是变量，而且是线程安全的，因为它的字符串操作方法加了同步锁。

StringBuilder对象也是变量，但是不是线程安全的，因为它的方法没有加锁。

## 5.hashmap

特性：
基于hashing（散列算法）原理
以键值对的方式存储数据
可以接受null键值和值
非线程安全的
速度快，执行效率高

工作原理：
HashMap是基于hashing的原理，我们使用put(key, value)存储对象到HashMap中，使用get(key)从HashMap中获取对象。当我们给put()方法传递键和值时，我们先对键调用hashCode()方法，返回的hashCode用于找到bucket位置来储存Entry对象。HashMap是在bucket中储存键对象和值对象，作为Map.Entry。

当两个对象的hashcode相同会发生什么：
因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。

如果两个键的hashcode相同，你如何获取值对象：
当我们调用get()方法，HashMap会使用键对象的hashcode找到bucket位置，然后获取值对象。如果有两个值对象储存在同一个bucket，找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper包装类作为键是非常好的选择。

如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办：
默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。

重新调整HashMap大小存在什么问题：
当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。

为什么String, Interger这样的wrapper类适合作为键：
 String, Interger这样的wrapper类作为HashMap的键是再适合不过了，而且String最为常用。因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能。

我们可以使用自定义的对象作为键吗：
可以使用任何对象作为键，只要它遵守了equals()和hashCode()方法的定义规则，并且当对象插入到Map中之后将不会再改变了。如果这个自定义对象时不可变的，那么它已经满足了作为键的条件，因为当它创建之后就已经不能改变了。

我们可以使用CocurrentHashMap来代替Hashtable吗：
我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。

## 6.死锁

死锁的原因：资源竞争

如何避免：方法加锁，一次性请求所需所有资源。

## 7.tcp三次握手

定义场景：客户端向服务端请求tcp连接

客户端主动请求，服务端被动接收

客户端发送带有SYN标志的数据包给服务端

服务端接收后发送带有SYN/ACK的确认数据包

客户端接收后发送带有ACK的数据包

为什么要三次握手？

因为tcp要求建立的连接是可靠的，可靠的含义是连接的双方都能确认自己和对方的收发功能都是正常的。

第一次握手：客户端什么都不能确认，服务端可以确认客户端发数据正常，自己收数据正常。

第二次握手：客户端确认自己收发数据正常，服务端也收发数据正常。服务端的确认情况不变。

第三次握手：客户端已经确认自己和对方都没问题。服务端确定自己收发正常，客户端也收发正常。

接下来就可以进行数据传输了。

## 8.tcp与udp的区别与联系

联系：都是传输层协议

区别：tcp面向连接，点对点通信，支持可靠消息传输。

​	   udp面向无连接，支持多对多的通讯，尽最大努力传输数据

## 9.在浏览器中输入url地址 ->> 显示主页的过程用到的协议

DNS：浏览器首先根据域名系统找到对应的ip地址

HTTP：浏览器向服务器发送HTTP请求

TCP：浏览器与服务器建立TCP连接

IP：双方通过IP协议在网络层中传输数据

路由选择协议：IP数据包在路由器之间传输使用路由选择协议

ARP：IP转链路层

## 10.为什么重写equals方法必须重写hashcode方法

equals()和hashcode()都是Object类的方法，equals比较两个对象的地址，也就是两个对象是不是相等的。等价于"=="，hashcode是根据对象内存地址经hash算法得来的。如果equals被重写，使得两个对象内容相同就可以被认为是相同对象。那么如果不重写hashcode()，就会发生根据hashcode判断两个对象不相等，而equals结果相等的情况。

